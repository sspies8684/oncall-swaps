Metadata-Version: 2.4
Name: oncall-swap
Version: 0.1.0
Summary: Oncall swap negotiation system with Slack and Opsgenie integrations.
Author: Oncall Automation
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Requires-Dist: pydantic>=2.6.0
Requires-Dist: slack-bolt>=1.18.1
Requires-Dist: requests>=2.32.3
Requires-Dist: httpx>=0.27.0

# Oncall Swap Negotiator

Python reference implementation of an on-call swap negotiation bot that coordinates regular and ring swaps between Opsgenie schedules and Slack users using a hexagonal architecture.

## Architecture Overview

- **Domain** (`oncall_swap.domain`): Value objects and aggregates (`SwapOffer`, `TimeWindow`, `RingSwap`) encapsulating negotiation state and invariants.
- **Application** (`oncall_swap.application`): `SwapNegotiationService` orchestrates use-cases (`create_offer`, `accept_cover`) across ports.
- **Ports** (`oncall_swap.ports`): Abstract interfaces for persistence, Slack interactions, Opsgenie integration, and participant directory lookups.
- **Adapters**:
  - `adapters.slack.SlackBotAdapter`: Slack Bolt bot with interactive select menus for swap offers and updates.
  - `adapters.opsgenie.OpsgenieClient`: HTTP client for Opsgenie timeline and overrides.
  - `infrastructure.*`: In-memory implementations for persistence and identity directory (suitable for tests).

```
┌────────────┐        ┌────────────────────┐        ┌────────────┐
│   Slack    │◀──────▶│ SlackBotAdapter    │◀──────▶│            │
└────────────┘        ├────────────────────┤        │            │
                      │ SwapNegotiationSvc │        │  Domain    │
┌────────────┐        ├────────────────────┤        │            │
│ Opsgenie   │◀──────▶│ OpsgenieClient     │◀──────▶│            │
└────────────┘        └────────────────────┘        └────────────┘
```

## Key Capabilities

- **Regular Swap**: First coverage acceptance from someone on-call during the search period immediately applies a two-way override in Opsgenie.
- **Ring Swap**: Participants outside the requested window can accept the `let_window` while contributing new windows that need coverage. The offer auto-extends with those windows, and the service closes the ring once every outstanding need can be satisfied (including by the requester).
- **Interactive Slack UX**: Offers and updates are published to a configurable channel, and individual prompts use interactive select menus to collect acceptance + alternate windows.

## Getting Started

1. **Install dependencies**

   ```bash
   pip install -e .
   ```

2. **Run the Slack bot**

     ```bash
     export SLACK_BOT_TOKEN=xoxb-...
     export SLACK_SIGNING_SECRET=...
     export SLACK_APP_TOKEN=xapp-...
     export OPSGENIE_API_KEY=...
     export OPSGENIE_SCHEDULE_ID=primary-oncall
     export SLACK_ANNOUNCEMENT_CHANNEL="#oncall-swaps"  # optional

     oncall-swap
     ```

     The CLI stitches together the in-memory repository/directory, Opsgenie client, and Slack adapter, launching a Socket Mode listener.
     - In Slack, run the `/swap-oncall` command to pick the shift you want to give away and the period you can cover instead.
     - Every trade option posted in the announcement thread has a **Respond** button. Clicking it opens a private modal that shows possible trade-in dates tagged with `[Direct]` or `[Ring]`, so responders immediately know whether they are closing the swap or extending the chain.

3. **Create an offer**

   ```python
   from datetime import datetime, timedelta
   from oncall_swap.application.commands import CreateOfferCommand, TimeWindowDTO

   command = CreateOfferCommand(
       requester_email="p1@example.com",
       schedule_id="primary-oncall",
       let_window=TimeWindowDTO(
           start=datetime(2025, 11, 10, 9, 0),
           end=datetime(2025, 11, 10, 21, 0),
       ),
       search_windows=[
           TimeWindowDTO(
               start=datetime(2025, 11, 12, 9, 0),
               end=datetime(2025, 11, 12, 21, 0),
           ),
           TimeWindowDTO(
               start=datetime(2025, 11, 13, 9, 0),
               end=datetime(2025, 11, 13, 21, 0),
           ),
       ],
   )

   offer = service.create_offer(command)
   ```

   Slack will broadcast the offer and individually prompt potential participants retrieved from Opsgenie.

4. **Handling acceptances**

   Slack interactive callbacks call `SwapNegotiationService.accept_cover`, automatically progressing towards either a direct swap or a ring swap and applying Opsgenie overrides.

## Testing

Plug the in-memory adapters into the service for deterministic unit tests. Example ring swap closure:

```python
from datetime import datetime, timedelta
from oncall_swap.application.commands import AcceptCoverCommand
from oncall_swap.application.services import SwapNegotiationService
```

> See `SwapNegotiationService._try_complete_ring` for the ring resolution algorithm tracing commitments.

## Next Steps

- Persist offers (e.g., Postgres) by implementing `OfferRepository`.
- Sync Slack user IDs into the participant directory to replace channel fallbacks.
- Extend Opsgenie client to support pagination and timezone-aware parsing.

## Continuous Integration

GitHub Actions (`.github/workflows/tests.yml`) installs the project and runs `pytest` on every push and pull request.

## Local Opsgenie Mock

For development you can import `MockOpsgenieClient` from `oncall_swap.adapters.opsgenie.mock`. It models a simple four-person rotation (`s+1@sloc.de` … `s+4@sloc.de`) and records overrides in memory—handy when you want to run the Slack workflow without hitting the real Opsgenie API.
